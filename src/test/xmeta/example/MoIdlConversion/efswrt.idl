











namespace Windows.Security.EnterpriseData
{
    [contractversion(5)]
    apicontract EnterpriseDataContract{};

    [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 1)]
    enum FileProtectionStatus
    {
        [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 1)]
        [deprecated("Undetermined might be unavailable after Windows 10. Instead, use Unknown.", deprecate, Windows.Security.EnterpriseData.EnterpriseDataContract, 0x10000)]
        Undetermined,
        [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 1)]
        Unknown = 0,
        Unprotected,
        Revoked,
        Protected,
        [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 1)]
        [deprecated("ProtectedByOtherUser might be unavailable after Windows 10. Instead, use ProtectedToOtherIdentity.", deprecate, Windows.Security.EnterpriseData.EnterpriseDataContract, 0x10000)]
        ProtectedByOtherUser,
        [deprecated("ProtectedToOtherEnterprise might be unavailable after Windows 10. Instead, use ProtectedToOtherIdentity.", deprecate, Windows.Security.EnterpriseData.EnterpriseDataContract, 0x10000)]
        [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 1)]
        ProtectedToOtherEnterprise,
        NotProtectable,
        [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 1)]
        ProtectedToOtherIdentity,
        [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 2)]
        LicenseExpired,
        [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 2)]
        AccessSuspended,
        [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 3)]
        FileInUse,
    };

    [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 1)]
    enum ProtectedImportExportStatus
    {
        Ok,
        Undetermined,
        Unprotected,
        Revoked,
        NotRoamable,
        ProtectedToOtherIdentity,
        [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 2)]
        LicenseExpired,
        [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 2)]
        AccessSuspended,
    };

    [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 1)]
    enum DataProtectionStatus
    {
        ProtectedToOtherIdentity,
        Protected,
        Revoked,
        Unprotected,
        [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 2)]
        LicenseExpired,
        [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 2)]
        AccessSuspended,
    };



    [dualapipartition(0xa000000)]
    [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 1)]
    [marshaling_behavior(agile)]
    [interface_name("Windows.Security.EnterpriseData.IFileProtectionInfo", 4ee96486-147e-4dd0-8faf-5253ed91ad0c)]
    runtimeclass FileProtectionInfo
    {
        Windows.Security.EnterpriseData.FileProtectionStatus Status{ get; };
        Boolean IsRoamable{ get; };
        String Identity{ get; };

        [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 5)]
        [interface_name("Windows.Security.EnterpriseData.IFileProtectionInfo2", 82123a4c-557a-498d-8e94-944cd5836432)]
        {
            Boolean IsProtectWhileOpenSupported{ get; };
        }
    }

    [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 1)]
    [marshaling_behavior(agile)]
    [dualapipartition(0xa000000)]
    [interface_name("Windows.Security.EnterpriseData.IProtectedContainerExportResult", 3948ef95-f7fb-4b42-afb0-df70b41543c1)]
    runtimeclass ProtectedContainerExportResult
    {
        Windows.Security.EnterpriseData.ProtectedImportExportStatus Status{ get; };
        Windows.Storage.StorageFile File{ get; };
    }

    [marshaling_behavior(agile)]
    [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 1)]
    [dualapipartition(0xa000000)]
    [interface_name("Windows.Security.EnterpriseData.IProtectedContainerImportResult", cdb780d1-e7bb-4d1a-9339-34dc41149f9b)]
    runtimeclass ProtectedContainerImportResult
    {
        Windows.Security.EnterpriseData.ProtectedImportExportStatus Status{ get; };
        Windows.Storage.StorageFile File{ get; };
    }

    [marshaling_behavior(agile)]
    [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 1)]
    [dualapipartition(0xa000000)]
    [interface_name("Windows.Security.EnterpriseData.IProtectedFileCreateResult", 28e3ed6a-e9e7-4a03-9f53-bdb16172699b)]
    runtimeclass ProtectedFileCreateResult
    {
        Windows.Storage.StorageFile File{ get; };
        Windows.Storage.Streams.IRandomAccessStream Stream{ get; };
        Windows.Security.EnterpriseData.FileProtectionInfo ProtectionInfo{ get; };
    }



    [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 4)]
    [marshaling_behavior(agile)]
    [dualapipartition(0xa000003)]
    [constructor_name("Windows.Security.EnterpriseData.IFileUnprotectOptionsFactory", 51aeb39c-da8c-4c3f-9bfb-cb73a7cce0dd)]
    [interface_name("Windows.Security.EnterpriseData.IFileUnprotectOptions", 7d1312f1-3b0d-4dd8-a1f8-1ec53822e2f3)]
    runtimeclass FileUnprotectOptions
    {
        [method_name( "Create" )] FileUnprotectOptions(Boolean audit);
        Boolean Audit{ set; };
        Boolean Audit{ get; };
    }









    [marshaling_behavior(agile)]
    [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 1)]
    [dualapipartition(0xa000000)]
    [interface_name("Windows.Security.EnterpriseData.IBufferProtectUnprotectResult", 47995edc-6cec-4e3a-b251-9e7485d79e7a)]
    runtimeclass BufferProtectUnprotectResult
    {
        Windows.Storage.Streams.IBuffer Buffer{ get; };
        Windows.Security.EnterpriseData.DataProtectionInfo ProtectionInfo{ get; };
    }

    [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 1)]
    [marshaling_behavior(agile)]
    [dualapipartition(0xa000000)]
    [interface_name("Windows.Security.EnterpriseData.IDataProtectionInfo", 8420b0c1-5e31-4405-9540-3f943af0cb26)]
    runtimeclass DataProtectionInfo
    {
        Windows.Security.EnterpriseData.DataProtectionStatus Status{ get; };
        String Identity{ get; };
    }



    [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 3)]
    enum ProtectionPolicyAuditAction
    {
        Decrypt,
        CopyToLocation,
        SendToRecipient,
        Other,
    };

    [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 3)]
    enum ProtectionPolicyRequestAccessBehavior
    {
        Decrypt,
        TreatOverridePolicyAsBlock,
    };


    [marshaling_behavior(agile)]
    [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 3)]
    [dualapipartition(0xa000002)]
    [constructor_name("Windows.Security.EnterpriseData.IProtectionPolicyAuditInfoFactory", 7ed4180b-92e8-42d5-83d4-25440b423549)]
    [interface_name("Windows.Security.EnterpriseData.IProtectionPolicyAuditInfo", 425ab7e4-feb7-44fc-b3bb-c3c4d7ecbebb)]
    runtimeclass ProtectionPolicyAuditInfo
    {
        [method_name( "Create" )] ProtectionPolicyAuditInfo(ProtectionPolicyAuditAction action, String dataDescription, String sourceDescription, String targetDescription);
        [method_name( "CreateWithActionAndDataDescription" )] ProtectionPolicyAuditInfo(ProtectionPolicyAuditAction action, String dataDescription);
        Windows.Security.EnterpriseData.ProtectionPolicyAuditAction Action{ set; };
        Windows.Security.EnterpriseData.ProtectionPolicyAuditAction Action{ get; };
        String DataDescription{ set; };
        String DataDescription{ get; };
        String SourceDescription{ set; };
        String SourceDescription{ get; };
        String TargetDescription{ set; };
        String TargetDescription{ get; };
    }





    [dualapipartition(0xa000000)]
    [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 1)]
    [marshaling_behavior(agile)]
    [default_interface]
    [interface_name("Windows.Security.EnterpriseData.IThreadNetworkContext", fa4ea8e9-ef13-405a-b12c-d7348c6f41fc)]
    runtimeclass ThreadNetworkContext
        : Windows.Foundation.IClosable
    {
    }

    [dualapipartition(0xa000000)]
    [marshaling_behavior(agile)]
    [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 1)]
    [static_name("Windows.Security.EnterpriseData.IProtectionPolicyManagerStatics", c0bffc66-8c3d-4d56-8804-c68f0ad32ec5)]
    [interface_name("Windows.Security.EnterpriseData.IProtectionPolicyManager", d5703e18-a08d-47e6-a240-9934d7165eb5)]
    [threading(both)]
    runtimeclass ProtectionPolicyManager
    {
        static Boolean IsIdentityManaged(String identity);
        static Boolean TryApplyProcessUIPolicy(String identity);
        static void ClearProcessUIPolicy();
        static Windows.Security.EnterpriseData.ThreadNetworkContext CreateCurrentThreadNetworkContext(String identity);
        static Windows.Foundation.IAsyncOperation <String>  GetPrimaryManagedIdentityForNetworkEndpointAsync(Windows.Networking.HostName endpointHost);
        static void RevokeContent(String identity);
        static Windows.Security.EnterpriseData.ProtectionPolicyManager GetForCurrentView();
        static event Windows.Foundation.EventHandler <Windows.Security.EnterpriseData.ProtectedAccessSuspendingEventArgs>  ProtectedAccessSuspending;
        static event Windows.Foundation.EventHandler <Windows.Security.EnterpriseData.ProtectedAccessResumedEventArgs>  ProtectedAccessResumed;
        static event Windows.Foundation.EventHandler <Windows.Security.EnterpriseData.ProtectedContentRevokedEventArgs>  ProtectedContentRevoked;
        static Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult CheckAccess(String sourceIdentity, String targetIdentity);
        [method_name("RequestAccessAsync")] static Windows.Foundation.IAsyncOperation <Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult>  RequestAccessAsync(String sourceIdentity, String targetIdentity);

        [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 4)]
        [static_name("Windows.Security.EnterpriseData.IProtectionPolicyManagerStatics4", 20b794db-ccbd-490f-8c83-49ccb77aea6c)]
        {
            static Boolean IsRoamableProtectionEnabled(String identity);
            [method_name("RequestAccessWithBehaviorAsync")] static Windows.Foundation.IAsyncOperation <Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult>  RequestAccessAsync(String sourceIdentity, String targetIdentity, ProtectionPolicyAuditInfo auditInfo, String messageFromApp, ProtectionPolicyRequestAccessBehavior behavior);
            [method_name("RequestAccessForAppWithBehaviorAsync")] static Windows.Foundation.IAsyncOperation <Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult>  RequestAccessForAppAsync(String sourceIdentity, String appPackageFamilyName, ProtectionPolicyAuditInfo auditInfo, String messageFromApp, ProtectionPolicyRequestAccessBehavior behavior);
            [method_name("RequestAccessToFilesForAppAsync")] static Windows.Foundation.IAsyncOperation <Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult>  RequestAccessToFilesForAppAsync(Windows.Foundation.Collections.IIterable <Windows.Storage.IStorageItem>  sourceItemList, String appPackageFamilyName, ProtectionPolicyAuditInfo auditInfo);
            [method_name("RequestAccessToFilesForAppWithMessageAndBehaviorAsync")] static Windows.Foundation.IAsyncOperation <Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult>  RequestAccessToFilesForAppAsync(Windows.Foundation.Collections.IIterable <Windows.Storage.IStorageItem>  sourceItemList, String appPackageFamilyName, ProtectionPolicyAuditInfo auditInfo, String messageFromApp, ProtectionPolicyRequestAccessBehavior behavior);
            [method_name("RequestAccessToFilesForProcessAsync")] static Windows.Foundation.IAsyncOperation <Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult>  RequestAccessToFilesForProcessAsync(Windows.Foundation.Collections.IIterable <Windows.Storage.IStorageItem>  sourceItemList, UInt32 processId, ProtectionPolicyAuditInfo auditInfo);
            [method_name("RequestAccessToFilesForProcessWithMessageAndBehaviorAsync")] static Windows.Foundation.IAsyncOperation <Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult>  RequestAccessToFilesForProcessAsync(Windows.Foundation.Collections.IIterable <Windows.Storage.IStorageItem>  sourceItemList, UInt32 processId, ProtectionPolicyAuditInfo auditInfo, String messageFromApp, ProtectionPolicyRequestAccessBehavior behavior);
            static Windows.Foundation.IAsyncOperation <Boolean>  IsFileProtectionRequiredAsync(Windows.Storage.IStorageItem target, String identity);
            static Windows.Foundation.IAsyncOperation <Boolean>  IsFileProtectionRequiredForNewFileAsync(Windows.Storage.IStorageFolder parentFolder, String identity, String desiredName);
            static String PrimaryManagedIdentity{ get; };
            static String GetPrimaryManagedIdentityForIdentity(String identity);
        }

        [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 2)]
        [static_name("Windows.Security.EnterpriseData.IProtectionPolicyManagerStatics2", b68f9a8c-39e0-4649-b2e4-070ab8a579b3)]
        {
            static Boolean HasContentBeenRevokedSince(String identity, Windows.Foundation.DateTime since);
            static Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult CheckAccessForApp(String sourceIdentity, String appPackageFamilyName);
            [method_name("RequestAccessForAppAsync")] static Windows.Foundation.IAsyncOperation <Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult>  RequestAccessForAppAsync(String sourceIdentity, String appPackageFamilyName);
            static Windows.Security.EnterpriseData.EnforcementLevel GetEnforcementLevel(String identity);
            static Boolean IsUserDecryptionAllowed(String identity);
            static Boolean IsProtectionUnderLockRequired(String identity);
            static event Windows.Foundation.EventHandler <Object>  PolicyChanged;
            static Boolean IsProtectionEnabled{ get; };
        }

        [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 3)]
        [static_name("Windows.Security.EnterpriseData.IProtectionPolicyManagerStatics3", 48ff9e8c-6a6f-4d9f-bced-18ab537aa015)]
        {
            [method_name("RequestAccessWithAuditingInfoAsync")] static Windows.Foundation.IAsyncOperation <Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult>  RequestAccessAsync(String sourceIdentity, String targetIdentity, ProtectionPolicyAuditInfo auditInfo);
            [method_name("RequestAccessWithMessageAsync")] static Windows.Foundation.IAsyncOperation <Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult>  RequestAccessAsync(String sourceIdentity, String targetIdentity, ProtectionPolicyAuditInfo auditInfo, String messageFromApp);
            [method_name("RequestAccessForAppWithAuditingInfoAsync")] static Windows.Foundation.IAsyncOperation <Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult>  RequestAccessForAppAsync(String sourceIdentity, String appPackageFamilyName, ProtectionPolicyAuditInfo auditInfo);
            [method_name("RequestAccessForAppWithMessageAsync")] static Windows.Foundation.IAsyncOperation <Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult>  RequestAccessForAppAsync(String sourceIdentity, String appPackageFamilyName, ProtectionPolicyAuditInfo auditInfo, String messageFromApp);
            static void LogAuditEvent(String sourceIdentity, String targetIdentity, ProtectionPolicyAuditInfo auditInfo);
        }
        String Identity{ set; };
        String Identity{ get; };

        [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 3)]
        [interface_name("Windows.Security.EnterpriseData.IProtectionPolicyManager2", abf7527a-8435-417f-99b6-51beaf365888)]
        {
            Boolean ShowEnterpriseIndicator{ set; };
            Boolean ShowEnterpriseIndicator{ get; };
        }
    }

    [dualapipartition(0xa000000)]
    [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 1)]
    [marshaling_behavior(agile)]
    [interface_name("Windows.Security.EnterpriseData.IProtectedAccessSuspendingEventArgs", 75a193e0-a344-429f-b975-04fc1f88c185)]
    runtimeclass ProtectedAccessSuspendingEventArgs
    {
        Windows.Foundation.Collections.IVectorView <String>  Identities{ get; };
        Windows.Foundation.DateTime Deadline{ get; };
        Windows.Foundation.Deferral GetDeferral();
    }

    [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 1)]
    [marshaling_behavior(agile)]
    [dualapipartition(0xa000000)]
    [interface_name("Windows.Security.EnterpriseData.IProtectedAccessResumedEventArgs", ac4dca59-5d80-4e95-8c5f-8539450eebe0)]
    runtimeclass ProtectedAccessResumedEventArgs
    {
        Windows.Foundation.Collections.IVectorView <String>  Identities{ get; };
    }

    [dualapipartition(0xa000000)]
    [marshaling_behavior(agile)]
    [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 1)]
    [interface_name("Windows.Security.EnterpriseData.IProtectedContentRevokedEventArgs", 63686821-58b9-47ee-93d9-f0f741cf43f0)]
    runtimeclass ProtectedContentRevokedEventArgs
    {
        Windows.Foundation.Collections.IVectorView <String>  Identities{ get; };
    }

    [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 2)]
    enum EnforcementLevel
    {
        NoProtection,
        Silent,
        Override,
        Block,
    };








    [deprecated("FileRevocationManager might be unavailable after Windows 10. Instead, use FileProtectionManager.", deprecate, Windows.Security.EnterpriseData.EnterpriseDataContract, 0x10000)]
    [dualapipartition(0x6030000)]
    [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 1)]
    [marshaling_behavior(agile)]
    [static_name("Windows.Security.EnterpriseData.IFileRevocationManagerStatics", 256bbc3d-1c5d-4260-8c75-9144cfb78ba9)]
    [threading(both)]
    runtimeclass FileRevocationManager
    {
        [deprecated("FileRevocationManager might be unavailable after Windows 10. Instead, use FileProtectionManager.", deprecate, Windows.Security.EnterpriseData.EnterpriseDataContract, 0x10000)]
        static Windows.Foundation.IAsyncOperation <Windows.Security.EnterpriseData.FileProtectionStatus>  ProtectAsync(Windows.Storage.IStorageItem storageItem, String enterpriseIdentity);
        [deprecated("FileRevocationManager might be unavailable after Windows 10. Instead, use FileProtectionManager.", deprecate, Windows.Security.EnterpriseData.EnterpriseDataContract, 0x10000)]
        static Windows.Foundation.IAsyncOperation <Boolean>  CopyProtectionAsync(Windows.Storage.IStorageItem sourceStorageItem, Windows.Storage.IStorageItem targetStorageItem);
        [deprecated("FileRevocationManager might be unavailable after Windows 10. Instead, use FileProtectionManager.", deprecate, Windows.Security.EnterpriseData.EnterpriseDataContract, 0x10000)]
        static void Revoke(String enterpriseIdentity);
        [deprecated("FileRevocationManager might be unavailable after Windows 10. Instead, use FileProtectionManager.", deprecate, Windows.Security.EnterpriseData.EnterpriseDataContract, 0x10000)]
        static Windows.Foundation.IAsyncOperation <Windows.Security.EnterpriseData.FileProtectionStatus>  GetStatusAsync(Windows.Storage.IStorageItem storageItem);
    }

    [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 1)]
    [dualapipartition(0xa000000)]
    [marshaling_behavior(agile)]
    [static_name("Windows.Security.EnterpriseData.IFileProtectionManagerStatics", 5846fc9b-e613-426b-bb38-88cba1dc9adb)]
    [threading(both)]
    runtimeclass FileProtectionManager
    {

        [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 2)]
        [static_name("Windows.Security.EnterpriseData.IFileProtectionManagerStatics2", 83d2a745-0483-41ab-b2d5-bc7f23d74ebb)]
        {
            static Windows.Foundation.IAsyncOperation <Boolean>  IsContainerAsync(Windows.Storage.IStorageFile file);
            [method_name("LoadFileFromContainerWithTargetAndNameCollisionOptionAsync")] [default_overload]
            static Windows.Foundation.IAsyncOperation <Windows.Security.EnterpriseData.ProtectedContainerImportResult>  LoadFileFromContainerAsync(Windows.Storage.IStorageFile containerFile, Windows.Storage.IStorageItem target, Windows.Storage.NameCollisionOption collisionOption);
            [default_overload]
            [method_name("SaveFileAsContainerWithSharingAsync")] static Windows.Foundation.IAsyncOperation <Windows.Security.EnterpriseData.ProtectedContainerExportResult>  SaveFileAsContainerAsync(Windows.Storage.IStorageFile protectedFile, Windows.Foundation.Collections.IIterable <String>  sharedWithIdentities);
        }
        static Windows.Foundation.IAsyncOperation <Windows.Security.EnterpriseData.FileProtectionInfo>  ProtectAsync(Windows.Storage.IStorageItem target, String identity);
        static Windows.Foundation.IAsyncOperation <Boolean>  CopyProtectionAsync(Windows.Storage.IStorageItem source, Windows.Storage.IStorageItem target);
        static Windows.Foundation.IAsyncOperation <Windows.Security.EnterpriseData.FileProtectionInfo>  GetProtectionInfoAsync(Windows.Storage.IStorageItem source);
        [method_name("SaveFileAsContainerAsync")] static Windows.Foundation.IAsyncOperation <Windows.Security.EnterpriseData.ProtectedContainerExportResult>  SaveFileAsContainerAsync(Windows.Storage.IStorageFile protectedFile);
        [method_name("LoadFileFromContainerAsync")] static Windows.Foundation.IAsyncOperation <Windows.Security.EnterpriseData.ProtectedContainerImportResult>  LoadFileFromContainerAsync(Windows.Storage.IStorageFile containerFile);
        [method_name("LoadFileFromContainerWithTargetAsync")] static Windows.Foundation.IAsyncOperation <Windows.Security.EnterpriseData.ProtectedContainerImportResult>  LoadFileFromContainerAsync(Windows.Storage.IStorageFile containerFile, Windows.Storage.IStorageItem target);
        static Windows.Foundation.IAsyncOperation <Windows.Security.EnterpriseData.ProtectedFileCreateResult>  CreateProtectedAndOpenAsync(Windows.Storage.IStorageFolder parentFolder, String desiredName, String identity, Windows.Storage.CreationCollisionOption collisionOption);

        [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 4)]
        [static_name("Windows.Security.EnterpriseData.IFileProtectionManagerStatics3", 6918849a-624f-46d6-b241-e9cd5fdf3e3f)]
        {
            [method_name("UnprotectAsync")] static Windows.Foundation.IAsyncOperation <Windows.Security.EnterpriseData.FileProtectionInfo>  UnprotectAsync(Windows.Storage.IStorageItem target);
            [method_name("UnprotectWithOptionsAsync")] static Windows.Foundation.IAsyncOperation <Windows.Security.EnterpriseData.FileProtectionInfo>  UnprotectAsync(Windows.Storage.IStorageItem target, FileUnprotectOptions options);
        }
    }

    [dualapipartition(0xa000000)]
    [contract(Windows.Security.EnterpriseData.EnterpriseDataContract, 1)]
    [marshaling_behavior(agile)]
    [static_name("Windows.Security.EnterpriseData.IDataProtectionManagerStatics", b6149b74-9144-4ee4-8a8a-30b5f361430e)]
    [threading(both)]
    runtimeclass DataProtectionManager
    {
        static Windows.Foundation.IAsyncOperation <Windows.Security.EnterpriseData.BufferProtectUnprotectResult>  ProtectAsync(Windows.Storage.Streams.IBuffer data, String identity);
        static Windows.Foundation.IAsyncOperation <Windows.Security.EnterpriseData.BufferProtectUnprotectResult>  UnprotectAsync(Windows.Storage.Streams.IBuffer data);
        static Windows.Foundation.IAsyncOperation <Windows.Security.EnterpriseData.DataProtectionInfo>  ProtectStreamAsync(Windows.Storage.Streams.IInputStream unprotectedStream, String identity, Windows.Storage.Streams.IOutputStream protectedStream);
        static Windows.Foundation.IAsyncOperation <Windows.Security.EnterpriseData.DataProtectionInfo>  UnprotectStreamAsync(Windows.Storage.Streams.IInputStream protectedStream, Windows.Storage.Streams.IOutputStream unprotectedStream);
        static Windows.Foundation.IAsyncOperation <Windows.Security.EnterpriseData.DataProtectionInfo>  GetProtectionInfoAsync(Windows.Storage.Streams.IBuffer protectedData);
        static Windows.Foundation.IAsyncOperation <Windows.Security.EnterpriseData.DataProtectionInfo>  GetStreamProtectionInfoAsync(Windows.Storage.Streams.IInputStream protectedStream);
    }

}
namespace Windows.Security.DataProtection
{
    [contract(Windows.Foundation.UniversalApiContract, 8)]
    enum UserDataAvailability
    {
        Always,
        AfterFirstUnlock,
        WhileUnlocked,
    };

    [contract(Windows.Foundation.UniversalApiContract, 8)]
    enum UserDataStorageItemProtectionStatus
    {
        Succeeded,
        NotProtectable,
        DataUnavailable,
    };

    [contract(Windows.Foundation.UniversalApiContract, 8)]
    enum UserDataBufferUnprotectStatus
    {
        Succeeded,
        Unavailable,
    };





    [contract(Windows.Foundation.UniversalApiContract, 8)]
    [marshaling_behavior(agile)]
    [static_name("Windows.Security.DataProtection.IUserDataProtectionManagerStatics", 977780e8-6dce-4fae-af85-782ac2cf4572)]
    [interface_name("Windows.Security.DataProtection.IUserDataProtectionManager", 1f13237d-b42e-4a88-9480-0f240924c876)]
    [threading(both)]
    runtimeclass UserDataProtectionManager
    {
        static Windows.Security.DataProtection.UserDataProtectionManager TryGetDefault();
        static Windows.Security.DataProtection.UserDataProtectionManager TryGetForUser(Windows.System.User user);
        Windows.Foundation.IAsyncOperation <Windows.Security.DataProtection.UserDataStorageItemProtectionStatus>  ProtectStorageItemAsync(Windows.Storage.IStorageItem storageItem, UserDataAvailability availability);
        Windows.Foundation.IAsyncOperation <Windows.Security.DataProtection.UserDataStorageItemProtectionInfo>  GetStorageItemProtectionInfoAsync(Windows.Storage.IStorageItem storageItem);
        Windows.Foundation.IAsyncOperation <Windows.Storage.Streams.IBuffer>  ProtectBufferAsync(Windows.Storage.Streams.IBuffer unprotectedBuffer, UserDataAvailability availability);
        Windows.Foundation.IAsyncOperation <Windows.Security.DataProtection.UserDataBufferUnprotectResult>  UnprotectBufferAsync(Windows.Storage.Streams.IBuffer protectedBuffer);
        Boolean IsContinuedDataAvailabilityExpected(UserDataAvailability availability);
        event Windows.Foundation.TypedEventHandler <Windows.Security.DataProtection.UserDataProtectionManager, Windows.Security.DataProtection.UserDataAvailabilityStateChangedEventArgs>  DataAvailabilityStateChanged;
    }


    [contract(Windows.Foundation.UniversalApiContract, 8)]
    [marshaling_behavior(agile)]
    [interface_name("Windows.Security.DataProtection.IUserDataStorageItemProtectionInfo", 5b6680f6-e87f-40a1-b19d-a6187a0c662f)]
    runtimeclass UserDataStorageItemProtectionInfo
    {
        Windows.Security.DataProtection.UserDataAvailability Availability{ get; };
    }

    [contract(Windows.Foundation.UniversalApiContract, 8)]
    [marshaling_behavior(agile)]
    [interface_name("Windows.Security.DataProtection.IUserDataBufferUnprotectResult", 8efd0e90-fa9a-46a4-a377-01cebf1e74d8)]
    runtimeclass UserDataBufferUnprotectResult
    {
        Windows.Security.DataProtection.UserDataBufferUnprotectStatus Status{ get; };
        Windows.Storage.Streams.IBuffer UnprotectedBuffer{ get; };
    }

    [contract(Windows.Foundation.UniversalApiContract, 8)]
    [marshaling_behavior(agile)]
    [interface_name("Windows.Security.DataProtection.IUserDataAvailabilityStateChangedEventArgs", a76582c9-06a2-4273-a803-834c9f87fbeb)]
    runtimeclass UserDataAvailabilityStateChangedEventArgs
    {
        Windows.Foundation.Deferral GetDeferral();
    }

}
